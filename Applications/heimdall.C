/***************************************************************************
 *
 *   Copyright (C) 2012 by Ben Barsdell and Andrew Jameson
 *   Licensed under the Academic Free License version 2.1
 *
 ***************************************************************************/

#include <iostream>
using std::cout;
using std::cerr;
using std::endl;
#include <sstream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <unistd.h>
#include <string.h>
#include <cstdlib>

#include "hd/parse_command_line.h"
#include "hd/default_params.h"
#include "hd/pipeline.h"
#include "hd/error.h"
#include "hd/types.h"
#include <dedisp.h>

// input formats supported
#include "hd/DataSource.h"
#include "hd/SigprocFile.h"
#ifdef HAVE_PSRDADA
#include "hd/PSRDadaRingBuffer.h"
#endif

#include "hd/stopwatch.h"


int main(int argc, char* argv[]) 
{
  hd_params params;
  hd_set_default_params(&params);
  int ok = hd_parse_command_line(argc, argv, &params);
  size_t nsamps_gulp = params.nsamps_gulp;
  size_t nsnap = params.nsnap;

  //  char cmd[200];
  
  if (ok < 0)
    return 1;
  
  DataSource* data_source = 0;

#ifdef HAVE_PSRDADA
  if( params.dada_id != 0 ) {

    if (params.verbosity)
      cerr << "Createing PSRDADA client" << endl;

    PSRDadaRingBuffer * d = new PSRDadaRingBuffer(params.dada_id);

    // Read from psrdada ring buffer
    if( !d || d->get_error() ) {
      cerr << "ERROR: Failed to initialise connection to psrdada" << endl;
      return -1;
    }

    if (params.verbosity)
      cerr << "Connecting to ring buffer" << endl;
    // connect to PSRDADA ring buffer
    if (! d->connect())
    {
       cerr << "ERROR: Failed to connection to psrdada ring buffer" << endl;
      return -1;
    }

    if (params.verbosity)
      cerr << "Waiting for next header / data" << endl;

    // wait for and then read next PSRDADA header/observation
    if (! d->read_header())
    {
       cerr << "ERROR: Failed to connection to psrdada ring buffer" << endl;
      return -1;
    }

    data_source = (DataSource *) d;
    if (!params.override_beam)
      params.beam = d->get_beam() - 1;
  }
  else 
  {
#endif
    // Read from filterbank file
    data_source = new SigprocFile(params.sigproc_file, params.fswap);
    if( !data_source || data_source->get_error() ) {
      cerr << "ERROR: Failed to open data file" << endl;
      return -1;
    }
#ifdef HAVE_PSRDADA
  }
#endif

  if (!params.override_beam)
    if (data_source->get_beam() > 0)
      params.beam = data_source->get_beam() - 1;
    else
      params.beam = 0;

  params.f0 = data_source->get_f0();
  params.df = data_source->get_df();
  params.dt = data_source->get_tsamp();

  if ( params.verbosity > 0)
    cout << "processing beam " << (params.beam+1)  << endl;

  float tsamp = data_source->get_tsamp() / 1000000;
  size_t stride = data_source->get_stride();
  //cout << stride << endl;
  params.beam_count = 10; 
  //cout << params.beam_count << endl;
  //cout << params.nchans << endl;
  size_t nbits  = data_source->get_nbit();

  params.nchans = data_source->get_nchan();
  params.utc_start = data_source->get_utc_start();
  params.spectra_per_second = data_source->get_spectra_rate();

  bool stop_requested = false;
  
  // Create the pipeline object
  // --------------------------
  hd_pipeline pipeline;
  hd_error error;
  error = hd_create_pipeline(&pipeline, params);
  if( error != HD_NO_ERROR ) {
    cerr << "ERROR: Pipeline creation failed" << endl;
    cerr << "       " << hd_get_error_string(error) << endl;
    return -1;
  }
  // --------------------------
size_t derror;
dedisp_plan dedispersion_plan;
derror = dedisp_create_plan(&dedispersion_plan,
                              params.nchans, params.dt,
                              params.f0, params.df);

derror = dedisp_generate_dm_list(dedispersion_plan,
                                   params.dm_min,
                                   params.dm_max,
                                   params.dm_pulse_width,
                                   params.dm_tol);
/*
 cout << "params.nchans " << params.nchans << endl;
 cout << "params.dt " << params.dt << endl;
 cout << "params.f0 " << params.f0 << endl;
 cout << "params.df " << params.df << endl; 
*/
 
  size_t max_delay = dedisp_get_max_delay(dedispersion_plan);
  //cout << "max delay " << max_delay << endl;
  size_t boxcar_max = params.boxcar_max;
  
  if ( params.verbosity >= 2)
    cout << "allocating filterbank data vector for " << (nsamps_gulp+max_delay+boxcar_max)*nsnap << " samples with size " << ((nsamps_gulp + max_delay + boxcar_max) * stride * nsnap * params.nbeams) << " bytes" << " with " << params.nbeams << " beams." <<  endl;
  std::vector<hd_byte> filterbank((nsamps_gulp + max_delay+boxcar_max)* stride * nsnap * params.nbeams);

  if( params.verbosity >= 1 ) {
    cout << "Beginning data processing, requesting " << nsamps_gulp << " samples" << endl;
  }

  // start a timer for the whole pipeline
  //Stopwatch pipeline_timer;

  char cmd[200];
  int fseq = 0;
  size_t cur_nsamps = 0;
  size_t total_nsamps = 0;
  size_t nsamps_read = 0;
  for (int i=0;i<params.nbeams;i++) {
    for (int j = i*(nsamps_gulp + max_delay+boxcar_max)*stride*nsnap; j < (i*(nsamps_gulp + max_delay+boxcar_max) + max_delay+boxcar_max)* stride * nsnap; j++)
      filterbank[j] = 128;
  nsamps_read += data_source->get_data (nsamps_gulp * nsnap, (char*)&filterbank[(i*(nsamps_gulp + max_delay+boxcar_max) + max_delay+boxcar_max)* stride * nsnap]);
  }
  nsamps_read = nsamps_read/params.nbeams;
  size_t overlap = 0;
  size_t gulp_idx = 0;

  //cout << "total_nsamps =" << total_nsamps << endl;   
  while( nsamps_read && !stop_requested )
  {
    
    if ( params.verbosity >= 1 ) { 
      cout << "Executing pipeline on new gulp of " << nsamps_gulp + max_delay + boxcar_max
           << " samples..." << endl;
      cout << "total_nsamps =" << total_nsamps << endl;
    }
    //pipeline_timer.start();

    // copy output file if needed, and reset total_nsamps
    /*    if (total_nsamps > 54931640) { // 7200 seconds

      cur_nsamps += total_nsamps;
      total_nsamps = 0;
      sprintf(cmd,"mv /mnt/nfs/data/heimdall/heimdall.cand /mnt/nfs/data/heimdall/heimdall_%d.cand",fseq);
      fseq++;
      system(cmd);

      }*/
    
    hd_size nsamps_processed;
    error = hd_execute(pipeline, &filterbank[0], nsamps_gulp + max_delay + boxcar_max, nbits,
                       total_nsamps, cur_nsamps, &nsamps_processed, gulp_idx);
    gulp_idx ++;
    if (error == HD_NO_ERROR)
    {
      if (params.verbosity >= 1)
        cout << "Processed " << nsamps_processed << " samples." << endl;
    }
    else if (error == HD_TOO_MANY_EVENTS) 
    {
      if (params.verbosity >= 1)
        cerr << "WARNING: hd_execute produces too many events, some data skipped" << endl;
    }
    else 
    {
      cerr << "ERROR: Pipeline execution failed" << endl;
      cerr << "       " << hd_get_error_string(error) << endl;
      hd_destroy_pipeline(pipeline);
      return -1;
    }

    if (params.verbosity >= 1)
      cout << "Main: nsamps_processed=" << nsamps_processed << endl;

    if (total_nsamps == 0) total_nsamps += nsamps_gulp - max_delay - boxcar_max;// - max_delay - boxcar_max;
    else total_nsamps += nsamps_processed;
    // Now we must 'rewind' to do samples that couldn't be processed
    //std::copy(&filterbank[nsamps_processed * stride * nsnap],
    //          &filterbank[(nsamps_read+overlap) * stride * nsnap],
    //          &filterbank[0]); // move the tail of the block to the beginning of the same filterband? 
    //overlap += nsamps_read - nsamps_processed;
    //nsamps_read = data_source->get_data((nsamps_gulp - overlap)*nsnap,
    //                                     (char*)&filterbank[overlap*stride*nsnap]);
    
    for (int i = 0; i < params.nbeams; i++){ 
      std::copy(&filterbank[((i*(nsamps_gulp + max_delay + boxcar_max) + nsamps_gulp)) * stride * nsnap],
                &filterbank[((i+1)*(nsamps_gulp + max_delay + boxcar_max)) * stride * nsnap],
                &filterbank[i * (nsamps_gulp + max_delay + boxcar_max) * stride * nsnap]);// or [i * (nsamps_read+overlap) * stride * nsnap])?  
      
      if (i == 0){
      //overlap += nsamps_read - nsamps_processed;
      } 
      nsamps_read = data_source->get_data((nsamps_gulp)*nsnap,
                                        (char*)&filterbank[(max_delay + boxcar_max + i * (nsamps_gulp + max_delay + boxcar_max)) * stride * nsnap]);
    }

    // at the end of data, never execute the pipeline
    if (nsamps_read < (nsamps_gulp - overlap)*nsnap) // why < ? not > ? 
      stop_requested = 1;
  }
 
  // final iteration for nsamps which is not a multiple of gulp size - overlap
  /*if (stop_requested) 
  {
    if (params.verbosity >= 1)
      cout << "Final sub gulp: nsamps_read=" << nsamps_read << " nsamps_gulp=" << nsamps_gulp << " overlap=" << overlap << endl;
    hd_size nsamps_processed;
    hd_size nsamps_to_process = nsamps_read/NSNAP + (overlap * 2 - params.boxcar_max);
    if (nsamps_to_process > nsamps_gulp)
      nsamps_to_process = nsamps_gulp;
    error = hd_execute(pipeline, &filterbank[0], nsamps_to_process, nbits, 
                       total_nsamps, &nsamps_processed);
    if (params.verbosity >= 1)
      cout << "Final sub gulp: nsamps_processed=" << nsamps_processed << endl;

    if (error == HD_NO_ERROR)
    { 
      if (params.verbosity >= 1)
        cout << "Processed " << nsamps_processed << " samples." << endl;
    }
    else if (error == HD_TOO_MANY_EVENTS)
    { 
      if (params.verbosity >= 1)
        cerr << "WARNING: hd_execute produces too many events, some data skipped" << endl;
    }
    else
    {
      cerr << "ERROR: Pipeline execution failed" << endl;
      cerr << "       " << hd_get_error_string(error) << endl;
    }
    total_nsamps += nsamps_processed;
    }*/
   
  if( params.verbosity >= 1 ) {
    cout << "Successfully processed a total of " << total_nsamps
         << " samples." << endl;
  }
    
  if( params.verbosity >= 1 ) {
    cout << "Shutting down..." << endl;
  }
  
  hd_destroy_pipeline(pipeline);
  
  if( params.verbosity >= 1 ) {
    cout << "All done." << endl;
  }
}
